::: warning 2048 游戏

一款经典的数字益智游戏。通过滑动方块，将相同数字的方块合并，最终目标是拼出2048！
:::

<div id="game2048" class="game-container">
  <div class="game-header">
    <div class="game-title">2048</div>
    <div class="game-stats">
      <div class="score-container">
        <div class="score-item">
          <div class="score-title">分数</div>
          <div class="score-value" id="score">0</div>
        </div>
        <div class="score-item">
          <div class="score-title">最佳</div>
          <div class="score-value" id="best-score">0</div>
        </div>
      </div>
      <button id="restart-button" class="btn-restart">重新开始</button>
    </div>
  </div>
  
  <div id="game-board"></div>
  <div id="game-over" class="hidden">
    <div class="game-over-content">
      <div class="game-over-text">游戏结束</div>
      <button id="restart-button-over">再玩一次</button>
    </div>
  </div>
  
  <div class="game-info">
    <h3>游戏目标</h3>
    <p>通过滑动数字方块，将相同数字的方块合并，持续合并直到拼出2048数字方块即可获胜！</p>
    <h3>操作方式</h3>
    <ul>
      <li>使用键盘方向键(↑ ↓ ← →)或WASD键控制方块移动</li>
      <li>在移动设备上，通过手指滑动屏幕控制方块移动</li>
      <li>点击重新开始按钮可重置游戏</li>
      <li>相同数字的方块合并时会获得分数</li>
    </ul>
  </div>
</div>

<script>
class Game2048 {
  constructor() {
    // 新游戏，不保存游戏状态，与其他游戏保持一致
    this.size = 4;
    this.board = [];
    this.score = 0;
    this.bestScore = localStorage.getItem('2048-best-score') ? parseInt(localStorage.getItem('2048-best-score')) : 0;
    this.won = false;
    this.over = false;
    this.gameBoardElement = null;
    this.mergedTiles = []; // 用于记录合并的方块位置
    this.initBoard();
    this.setupEventListeners();
    this.render();
    this.updateScoreDisplay();
  }

  initBoard() {
    this.board = Array(this.size).fill().map(() => Array(this.size).fill(0));
    this.addRandomTile();
    this.addRandomTile();
  }

  addRandomTile() {
    const emptyCells = [];
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.board[i][j] === 0) {
          emptyCells.push({ i, j });
        }
      }
    }
    
    if (emptyCells.length > 0) {
      const { i, j } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      this.board[i][j] = Math.random() < 0.9 ? 2 : 4;
    }
  }

  move(direction) {
    if (this.over || this.won) return; // 游戏结束或获胜时不允许移动
    
    let moved = false;
    
    if (direction === 'left') {
      moved = this.moveLeft();
    } else if (direction === 'right') {
      moved = this.moveRight();
    } else if (direction === 'up') {
      moved = this.moveUp();
    } else if (direction === 'down') {
      moved = this.moveDown();
    }
    
    console.log('[2048游戏] 移动结果:', { direction, moved });
    
    if (moved) {
      this.addRandomTile();
      this.render();
      
      // 使用正确的游戏结束检查
      this.checkGameOver();
    }
  }
  
  checkGameOver() {
    console.log('[2048游戏] 开始游戏结束检查');
    console.log('[2048游戏] 当前棋盘状态:', JSON.stringify(this.board));
    
    // 首先检查是否获胜
    if (this.hasWon()) {
      this.won = true;
      this.showGameWon();
      console.log('[2048游戏] 玩家获胜');
      return;
    }
    
    // 检查是否有空位
    let hasEmpty = false;
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.board[i][j] === 0) {
          hasEmpty = true;
          console.log('[2048游戏] 找到空位，位置:', { i, j });
          break;
        }
      }
      if (hasEmpty) {
        console.log('[2048游戏] 还有空位，游戏继续');
        return; // 还有空位，游戏未结束
      }
    }
    
    // 检查是否有可合并的相邻方块，确保检查所有四个方向
    let canMerge = false;
    let i, j;
    for (i = 0; i < this.size; i++) {
      for (j = 0; j < this.size; j++) {
        const current = this.board[i][j];
        
        console.log('[2048游戏] 检查位置:', {i, j}, '值:', current);
        
        // 检查右侧
        if (j < this.size - 1 && this.board[i][j + 1] === current) {
          canMerge = true;
          console.log('[2048游戏] 右侧可合并，位置:', { i, j }, '和', { i, j: j + 1 }, '值:', current);
          break;
        }
        // 检查左侧
        if (j > 0 && this.board[i][j - 1] === current) {
          canMerge = true;
          console.log('[2048游戏] 左侧可合并，位置:', { i, j }, '和', { i, j: j - 1 }, '值:', current);
          break;
        }
        // 检查下方
        if (i < this.size - 1 && this.board[i + 1][j] === current) {
          canMerge = true;
          console.log('[2048游戏] 下方可合并，位置:', { i, j }, '和', { i: i + 1, j }, '值:', current);
          break;
        }
        // 检查上方
        if (i > 0 && this.board[i - 1][j] === current) {
          canMerge = true;
          console.log('[2048游戏] 上方可合并，位置:', { i, j }, '和', { i: i - 1, j }, '值:', current);
          break;
        }
      }
      if (canMerge) {
        console.log('[2048游戏] 有可合并方块，游戏继续');
        return; // 有可合并方块，游戏未结束
      }
    }
    
    // 如果没有空位且无可合并方块，游戏结束
    console.log('[2048游戏] 游戏结束! 没有空位且无可合并方块');
    this.over = true;
    this.showGameOver();
  }

  moveLeft() {
    let moved = false;
    this.mergedTiles = []; // 清空上一次的合并记录
    
    for (let i = 0; i < this.size; i++) {
      const row = this.board[i].filter(val => val !== 0);
      
      const mergedRow = [];
      let skip = false;
      for (let j = 0; j < row.length; j++) {
        if (skip) {
          skip = false;
          continue;
        }
        
        if (j < row.length - 1 && row[j] === row[j + 1]) {
          mergedRow.push(row[j] * 2);
          this.score += row[j] * 2;
          skip = true;
          moved = true;
          // 记录合并位置
          const newJ = mergedRow.length - 1; // 合并后的新位置
          this.mergedTiles.push({ i, j: newJ });
        } else {
          mergedRow.push(row[j]);
        }
      }
      
      while (mergedRow.length < this.size) {
        mergedRow.push(0);
      }
      
      if (JSON.stringify(this.board[i]) !== JSON.stringify(mergedRow)) {
        moved = true;
      }
      
      this.board[i] = mergedRow;
    }
    
    // 更新分数显示
    this.updateScoreDisplay();
    console.log('[moveLeft] mergedTiles:', this.mergedTiles);
    return moved;
  }

  moveRight() {
    console.log('[moveRight] before reverse - board:', JSON.stringify(this.board));
    this.reverseBoard();
    console.log('[moveRight] after reverse - board:', JSON.stringify(this.board));
    const moved = this.moveLeft();
    console.log('[moveRight] after moveLeft - mergedTiles:', this.mergedTiles);
    
    // 调整合并方块的位置
    this.mergedTiles = this.mergedTiles.map(tile => ({
      i: tile.i,
      j: this.size - 1 - tile.j
    }));
    console.log('[moveRight] after adjust - mergedTiles:', this.mergedTiles);
    
    this.reverseBoard();
    console.log('[moveRight] final board:', JSON.stringify(this.board));
    return moved;
  }

  moveUp() {
    console.log('[moveUp] before transpose - board:', JSON.stringify(this.board));
    this.transposeBoard();
    console.log('[moveUp] after transpose - board:', JSON.stringify(this.board));
    const moved = this.moveLeft();
    console.log('[moveUp] after moveLeft - mergedTiles:', this.mergedTiles);
    
    // 调整合并方块的位置
    this.mergedTiles = this.mergedTiles.map(tile => ({
      i: tile.j,
      j: tile.i
    }));
    console.log('[moveUp] after adjust - mergedTiles:', this.mergedTiles);
    
    this.transposeBoard();
    console.log('[moveUp] final board:', JSON.stringify(this.board));
    return moved;
  }

  moveDown() {
    console.log('[moveDown] before transpose - board:', JSON.stringify(this.board));
    this.transposeBoard();
    console.log('[moveDown] after transpose - board:', JSON.stringify(this.board));
    const moved = this.moveRight();
    console.log('[moveDown] after moveRight - mergedTiles:', this.mergedTiles);
    
    // 调整合并方块的位置
    this.mergedTiles = this.mergedTiles.map(tile => ({
      i: tile.j,
      j: tile.i
    }));
    console.log('[moveDown] after adjust - mergedTiles:', this.mergedTiles);
    
    this.transposeBoard();
    console.log('[moveDown] final board:', JSON.stringify(this.board));
    return moved;
  }

  reverseBoard() {
    this.board.forEach(row => row.reverse());
  }

  transposeBoard() {
    this.board = this.board[0].map((_, colIndex) => this.board.map(row => row[colIndex]));
  }

  isGameOver() {
    // 检查是否有空位
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.board[i][j] === 0) {
          return false; // 有空位，游戏未结束
        }
      }
    }
    
    // 检查所有相邻方向的相同数字
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        const current = this.board[i][j];
        
        // 检查右侧
        if (j < this.size - 1 && this.board[i][j + 1] === current) {
          return false; // 右侧有相同数字，游戏未结束
        }
        
        // 检查左侧
        if (j > 0 && this.board[i][j - 1] === current) {
          return false; // 左侧有相同数字，游戏未结束
        }
        
        // 检查下方
        if (i < this.size - 1 && this.board[i + 1][j] === current) {
          return false; // 下方有相同数字，游戏未结束
        }
        
        // 检查上方
        if (i > 0 && this.board[i - 1][j] === current) {
          return false; // 上方有相同数字，游戏未结束
        }
      }
    }
    
    return true; // 没有空位且无可合并的相邻数字，游戏结束
  }

  showGameOver() {
    const gameOver = document.getElementById('game-over');
    if (gameOver) gameOver.classList.remove('hidden');
  }
  
  showGameWon() {
    // 如果没有游戏胜利元素，先创建
    const gameWonElement = document.createElement('div');
    gameWonElement.id = 'game-won';
    gameWonElement.className = '';
    gameWonElement.innerHTML = `
      <div class='game-over-content'>
        <div class='game-over-text'>恭喜你，游戏胜利！</div>
        <button id='restart-button-won'>再玩一次</button>
      </div>
    `;
    document.getElementById('game2048').appendChild(gameWonElement);
    
    // 添加重新开始按钮事件监听
    const restartButtonWon = document.getElementById('restart-button-won');
    if (restartButtonWon) {
      restartButtonWon.addEventListener('click', () => {
        this.restart();
        gameWonElement.remove();
      });
    }
  }
  
  hasWon() {
    // 检查是否有2048方块
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.board[i][j] === 2048) {
          return true;
        }
      }
    }
    return false;
  }

  hideGameOver() {
    const gameOver = document.getElementById('game-over');
    if (gameOver) gameOver.classList.add('hidden');
  }

  restart() {
    this.score = 0;
    this.won = false;
    this.over = false;
    this.initBoard();
    this.hideGameOver();
    this.updateScoreDisplay();
    this.render();
  }

  updateScoreDisplay() {
    const scoreElement = document.getElementById('score');
    const bestScoreElement = document.getElementById('best-score');
    if (scoreElement) scoreElement.textContent = this.score;
    if (bestScoreElement) bestScoreElement.textContent = this.bestScore;
    
    // 更新最佳分数到本地存储
    if (this.score > this.bestScore) {
      this.bestScore = this.score;
      localStorage.setItem('2048-best-score', this.bestScore);
      if (bestScoreElement) bestScoreElement.textContent = this.bestScore;
    }
  }
  
  render() {
    this.gameBoardElement = document.getElementById('game-board');
    if (!this.gameBoardElement) return;
    
    this.gameBoardElement.innerHTML = '';
    
    // 根据屏幕大小动态调整棋盘尺寸，解决移动端适配
    let boardSize;
    const screenWidth = window.innerWidth;
    if (screenWidth < 400) {
      boardSize = screenWidth - 40; // 小屏幕留边距
    } else if (screenWidth < 500) {
      boardSize = screenWidth - 60;
    } else {
      boardSize = 400;
    }
    const gap = 10; // 缩小间隙以适应小屏幕
    const tileSize = (boardSize - (gap * (this.size + 1))) / this.size;
    
    // 设置游戏板样式
    this.gameBoardElement.style.width = `${boardSize}px`;
    this.gameBoardElement.style.height = `${boardSize}px`;
    this.gameBoardElement.style.position = 'relative';
    this.gameBoardElement.style.backgroundColor = '#bbada0';
    this.gameBoardElement.style.borderRadius = '8px';
    this.gameBoardElement.style.margin = '0 auto';
    
    const tileColors = {
      2: '#eee4da',
      4: '#ede0c8',
      8: '#f2b179',
      16: '#f59563',
      32: '#f67c5f',
      64: '#f65e3b',
      128: '#edcf72',
      256: '#edcc61',
      512: '#edc850',
      1024: '#edc53f',
      2048: '#edc22e'
    };
    
    const tileTextColors = {
      2: '#776e65',
      4: '#776e65',
      8: 'white',
      16: 'white',
      32: 'white',
      64: 'white',
      128: 'white',
      256: 'white',
      512: 'white',
      1024: 'white',
      2048: 'white'
    };
    
    // 渲染空格子（背景格子）
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        const emptyTile = document.createElement('div');
        emptyTile.className = 'empty-tile';
        emptyTile.style.position = 'absolute';
        emptyTile.style.left = `${gap + j * (tileSize + gap)}px`;
        emptyTile.style.top = `${gap + i * (tileSize + gap)}px`;
        emptyTile.style.width = `${tileSize}px`;
        emptyTile.style.height = `${tileSize}px`;
        emptyTile.style.backgroundColor = '#cdc1b4';
        emptyTile.style.borderRadius = '8px';
        emptyTile.style.zIndex = '1';
        this.gameBoardElement.appendChild(emptyTile);
      }
    }
    
    // 渲染数字方块
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        const value = this.board[i][j];
        if (value !== 0) {
          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.style.position = 'absolute';
          tile.style.left = `${gap + j * (tileSize + gap)}px`;
          tile.style.top = `${gap + i * (tileSize + gap)}px`;
          tile.style.width = `${tileSize}px`;
          tile.style.height = `${tileSize}px`;
          tile.style.backgroundColor = tileColors[value] || tileColors[2];
          tile.style.color = tileTextColors[value] || tileTextColors[2];
          tile.style.borderRadius = '8px';
          tile.style.display = 'flex';
          tile.style.justifyContent = 'center';
          tile.style.alignItems = 'center';
          tile.style.fontWeight = 'bold';
          tile.textContent = value;
          
          if (value >= 1024) {
            tile.style.fontSize = '16px';
          } else if (value >= 128) {
            tile.style.fontSize = '20px';
          } else {
            tile.style.fontSize = '24px';
          }
          
          tile.style.zIndex = '10';
          
          // 为合并的方块添加碰撞特效
          const isMerged = this.mergedTiles.some(t => t.i === i && t.j === j);
          if (isMerged) {
            // 应用明显的合并动画
            tile.style.animation = 'collisionMergeEffect 0.5s ease-out';
            tile.style.zIndex = '100';
          } else {
            // 新出现的方块添加淡入效果
            tile.style.animation = 'appearEffect 0.3s ease-out';
          }
          
          this.gameBoardElement.appendChild(tile);
        }
      }
    }
    
    // 清空合并记录，以便下一次移动
    setTimeout(() => {
      this.mergedTiles = [];
    }, 500);
    
  }

  setupEventListeners() {
    const handleKeyDown = (e) => {
      switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          e.preventDefault();
          this.move('up');
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          e.preventDefault();
          this.move('down');
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          e.preventDefault();
          this.move('left');
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          e.preventDefault();
          this.move('right');
          break;
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    
    let startX, startY;
    let touchStartedOnBoard = false; // 记录触摸是否开始于棋盘区域
    const SWIPE_THRESHOLD = 30; // 滑动阈值，防止点击触发
    
    const handleTouchStart = (e) => {
      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
      
      // 检查触摸点是否在棋盘区域内
      const gameBoardElement = document.getElementById('game-board');
      if (gameBoardElement) {
        const rect = gameBoardElement.getBoundingClientRect();
        touchStartedOnBoard = touch.clientX >= rect.left && 
                             touch.clientX <= rect.right && 
                             touch.clientY >= rect.top && 
                             touch.clientY <= rect.bottom;
      } else {
        touchStartedOnBoard = false;
      }
    };
    
    const handleTouchMove = (e) => {
      // 只在触摸开始于棋盘区域时阻止默认行为
      if (touchStartedOnBoard) {
        e.preventDefault();
      }
    };
    
    const handleTouchEnd = (e) => {
      if (!startX || !startY) return;
      
      // 只在触摸开始于棋盘区域时处理滑动
      if (!touchStartedOnBoard) {
        startX = startY = null;
        return;
      }
      
      const endX = e.changedTouches[0].clientX;
      const endY = e.changedTouches[0].clientY;
      
      const diffX = startX - endX;
      const diffY = startY - endY;
      
      // 检查滑动距离是否超过阈值
      if (Math.abs(diffX) < SWIPE_THRESHOLD && Math.abs(diffY) < SWIPE_THRESHOLD) {
        startX = startY = null;
        return; // 距离太短，视为点击而不是滑动
      }
      
      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > 0) {
          this.move('left');
        } else {
          this.move('right');
        }
      } else {
        if (diffY > 0) {
          this.move('up');
        } else {
          this.move('down');
        }
      }
      
      startX = startY = null;
      touchStartedOnBoard = false;
    };
    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });
    
    const restartButtons = document.querySelectorAll('#restart-button, #restart-button-over, #restart-button-won');
    restartButtons.forEach(button => {
      button.addEventListener('click', () => this.restart());
    });
  }
}

(function() {
  let game2048Instance = null;
  let globalObserver = null;
  
  function checkAndInitGame(reset = false) {
    if (typeof window === 'undefined' || typeof document === 'undefined') return false;
    
    const gameContainer = document.getElementById('game2048');
    const gameBoard = document.getElementById('game-board');
    
    console.log('[2048游戏] 检查游戏元素:', { gameContainer: !!gameContainer, gameBoard: !!gameBoard });
    
    // 如果游戏实例已经存在且不需要重置，直接返回
    if (game2048Instance && !reset) {
      console.log('[2048游戏] 游戏实例已存在，跳过重复创建');
      return true;
    }
    
    if (gameContainer && gameBoard) {
      try {
        console.log('[2048游戏] 开始初始化游戏');
        // 不恢复游戏状态，始终创建新游戏
        game2048Instance = new Game2048();
        console.log('[2048游戏] 游戏初始化完成');
        return true;
      } catch (error) {
        console.error('2048 游戏初始化失败:', error);
        return false;
      }
    }
    return false;
  }
  
  function setupDOMObserver() {
    console.log('[2048游戏] 设置 DOM 观察器');
    
    const observer = new MutationObserver(function(mutationsList) {
      console.log('[2048游戏] DOM 变化观察到:', mutationsList.length);
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
          if (checkAndInitGame()) {
            console.log('[2048游戏] 通过 DOM 观察器成功初始化');
            observer.disconnect();
            return;
          }
        }
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    return observer;
  }
  
  function handleRouteChange() {
    console.log('[2048游戏] 路由变化，尝试重新初始化并重置游戏');
    // 路由变化时重置游戏状态，确保用户返回时重新开始
    game2048Instance = null;
    // 延迟检查，确保 VuePress 有足够时间渲染页面
    setTimeout(function() {
      if (!checkAndInitGame(true)) { // 使用true参数强制重置游戏
        // 如果立即初始化失败，设置 DOM 观察器
        globalObserver = setupDOMObserver();
      }
    }, 1000);
  }
  
  // 检查是否在浏览器环境中
  function isBrowser() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  
  // 在多种情况下尝试初始化游戏
  if (isBrowser()) {
    let initialized = false;
    
    // 1. 立即尝试
    console.log('[2048游戏] 立即尝试初始化...');
    setTimeout(function() {
      if (!initialized && checkAndInitGame()) {
        initialized = true;
      }
    }, 200);
    
    // 2. DOMContentLoaded事件
    document.addEventListener('DOMContentLoaded', function() {
      console.log('[2048游戏] DOMContentLoaded事件触发...');
      setTimeout(function() {
        if (!initialized && checkAndInitGame()) {
          initialized = true;
        }
      }, 100);
    });
    
    // 3. window.load事件
    window.addEventListener('load', function() {
      console.log('[2048游戏] window.load事件触发...');
      setTimeout(function() {
        if (!initialized && checkAndInitGame()) {
          initialized = true;
        }
      }, 50);
    });
    
    // 4. 2秒后再次尝试（作为备用）
    setTimeout(function() {
      console.log('[2048游戏] 备用初始化尝试...');
      if (!initialized && checkAndInitGame()) {
        initialized = true;
      }
    }, 2000);
    
    // 5. 监听所有可能的页面显示/隐藏和路由变化事件
    document.addEventListener('visibilitychange', () => {
      console.log('[2048游戏] 页面可见性变化:', document.visibilityState);
      if (document.visibilityState === 'visible') {
        setTimeout(function() {
          console.log('[2048游戏] 页面变为可见，检查游戏是否需要更新');
          // 只有当游戏实例不存在时才初始化，否则保持现有游戏状态
          if (!game2048Instance) {
            checkAndInitGame();
          } else {
            console.log('[2048游戏] 游戏已存在，保持当前状态');
            // 重新渲染棋盘，确保显示正确
            if (game2048Instance.render) {
              game2048Instance.render();
            }
          }
        }, 100);
      }
    });
    
    window.addEventListener('focus', () => {
      setTimeout(function() {
        console.log('[2048游戏] 窗口获得焦点，检查游戏是否需要更新');
        // 只有当游戏实例不存在时才初始化，否则保持现有游戏状态
        if (!game2048Instance) {
          checkAndInitGame();
        } else {
          console.log('[2048游戏] 游戏已存在，保持当前状态');
          // 重新渲染棋盘，确保显示正确
          if (game2048Instance.render) {
            game2048Instance.render();
          }
        }
      }, 100);
    });
    
    window.addEventListener('pageshow', (event) => {
      setTimeout(function() {
        console.log('[2048游戏] 页面显示事件，检查游戏是否需要更新:', event);
        // 只有当游戏实例不存在时才初始化，否则保持现有游戏状态
        if (!game2048Instance) {
          checkAndInitGame();
        } else {
          console.log('[2048游戏] 游戏已存在，保持当前状态');
          // 重新渲染棋盘，确保显示正确
          if (game2048Instance.render) {
            game2048Instance.render();
          }
        }
      }, 100);
    });
    
    window.addEventListener('hashchange', handleRouteChange);
    window.addEventListener('popstate', handleRouteChange);
  }
})();
</script>

<style scoped>
#game2048 {
  font-family: 'Arial', sans-serif;
  margin: 20px 0;
  text-align: center;
}

.game-container {
  max-width: 500px;
  margin: 0 auto;
}

.game-header {
  margin-bottom: 20px;
}

.game-title {
  font-size: 32px;
  font-weight: bold;
  color: #776e65;
  margin-bottom: 20px;
}

.game-stats {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 30px;
  flex-wrap: wrap;
}

.score-container {
  display: flex;
  gap: 20px;
}

.score-item {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  text-align: center;
  min-width: 80px;
}

.score-title {
  font-size: 12px;
  opacity: 0.9;
  margin-bottom: 5px;
}

.score-value {
  font-size: 20px;
  font-weight: bold;
}

.btn-restart {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s ease;
  white-space: nowrap;
  min-width: 100px;
}

#restart-button, #restart-button-over, #restart-button-won {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s ease;
  white-space: nowrap;
  min-width: 100px;
}

#restart-button:hover, #restart-button-over:hover, #restart-button-won:hover, .btn-restart:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#restart-button:active, #restart-button-over:active, #restart-button-won:active, .btn-restart:active {
  transform: translateY(0);
}

#game-board {
  position: relative;
  margin: 0 auto;
}

.empty-tile {
  /* 样式已在JavaScript中动态设置 */
}

.tile {
  /* 样式已在JavaScript中动态设置 */
}

#game-over, #game-won {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.game-info {
  margin-top: 30px;
  padding: 20px;
  background-color: #f8f9fa;
  border-radius: 10px;
  text-align: left;
  max-width: 500px;
  margin-left: auto;
  margin-right: auto;
}

.game-info h3 {
  color: #776e65;
  margin-top: 20px;
  margin-bottom: 10px;
  font-size: 18px;
}

.game-info p {
  color: #6c757d;
  line-height: 1.6;
  margin-bottom: 10px;
}

.game-info ul {
  color: #6c757d;
  padding-left: 20px;
  line-height: 1.8;
}

.game-info li {
  margin-bottom: 8px;
}

#game-over.hidden {
  display: none;
}

.game-over-content {
  background-color: white;
  padding: 30px;
  border-radius: 10px;
  text-align: center;
}

.game-over-text {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 20px;
}
@keyframes collisionMergeEffect {
  0% {
    transform: scale(1);
    opacity: 1;
    box-shadow: 0 0 0 0 rgba(237, 194, 46, 0);
  }
  50% {
    transform: scale(1.4);
    opacity: 1;
    box-shadow: 0 0 40px 30px rgba(237, 194, 46, 1);
  }
  100% {
    transform: scale(1);
    opacity: 1;
    box-shadow: 0 0 0 0 rgba(237, 194, 46, 0);
  }
}

@keyframes appearEffect {
  0% {
    transform: scale(0);
    opacity: 0;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

</style>